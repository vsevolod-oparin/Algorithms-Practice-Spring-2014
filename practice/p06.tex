\section{Практика 6. Структуры данных для хэширования}

\subsection{Практика}

\begin{itemize}
  \item Рассказать на разборе про $k$-независимые функции через полиномы.
  
  \item Пусть дана хэш-таблица размера $n$ с хэш-функцией $h : K \rightarrow [n]$. На вход поступает $n$ ключей. Будем предполагать, что хэш-функция отправляет каждый ключ в каждую ячейку независимо с равной вероятностью.
      
      Посчитаем длину максимальной по длине целочки.
      \begin{enumerate}
          \item Зафиксируем хэш-значение $x$. Доказать, что вероятность, что $k$ ключей будут иметь хэш $x$ составляет
          $$
              Q_k = \binom{n}{k} \cdot \left( \frac{1}{n} \right)^k \cdot  \left( 1 - \frac{1}{n} \right)^{n - k}.
          $$
          \item Пусть $P_k$ -- вероятность максимальной цепочки иметь длину $k$. Доказать, что $P_k \leq n \cdot Q_k$.
          \item Вывести из Стрилинга, что $Q_k < (\frac{e}{k})^k$.
          \item Показать, что для некоторого $c > 1$ верно $Q_k \leq \frac{1}{n^3}$ при 
          $k \geq c \cdot \frac{\log n}{\log \log n}$.
          \item Доказать, что мат.ожидание длины цепочки не превосходит
          $$
              \Prbb{}{ M > c \cdot \frac{\log n}{\log \log n} } \cdot n + \Prbb{}{ M \leq c \cdot \frac{\log n}{\log \log n} } \cdot c \cdot \frac{\log n}{\log \log n}.
          $$
          
          Вывести оценку сверху $O(\frac{\log n}{\log \log n})$.
      \end{enumerate}
  
  \item В этой задаче мы построим совершенное хэширование. Это такая таблица, 
  которая позволяет по имеющимся $n$ ключам из множества $K$, построить таблицу
  использующую $O(n)$ памяти и отвечающую на каждый запрос за $O(1)$ в худшем 
  случае.
  \begin{enumerate}
    \item Пусть дана СВ $X$, принимающая целые неотрицательные значения. 
      Известно, что $\Exb{}{ X > 0 } \leq \frac{1}{2}$. Докажите, что
      $\Prbb{}{X > 0} \leq \frac{1}{2}$.

    \item Пусть есть множество ключей $K$, и для любого $m$ мы можем подобрать
      универсальное семейство хэш-функций $\H_m = \{ h_i : K \rightarrow [m] \}$.
      Подберите такое $m$, что по мат. ожиданию за константное число попыток
      можно подобрать хэш-функцию, не дающую коллизий.

    \item Пусть $\H_m = \{ h_i : K \rightarrow [m] \}$ универсальное семейство 
      хэш-функций.  В таблице $T$ будем разрешать коллизии через цепочки. 
      Пусть $C_i$ -- длина цепочки в ячейке $i$. Докажите, что 
        $$\Exb{h}{ \sum_i \frac{C_i \cdot (C_i - 1)}{2} } = \frac{n \cdot (n - 1)}{2} \cdot \frac{1}{m}$$.

    \item Пусть теперь каждую цепочку в табоице $T$ мы заменим на хэш-таблицу 
    $T_i$ со своей хэш-функцией $h_i$. Подберите размеры таблиц $T_i$, чтобы 
    в них не было коллизий и размер таблицы $T$, чтобы суммарная память занимаемая
    всеми таблицами была $O(n)$.

    \item Докажите, что по имеющимся $n$ ключам можно построить хэш-таблицу по 
    мат. ожиданию за $O(n)$ времени и $O(n)$ памяти. Покажите, что каждый запрос
    обрабатывается за $O(1)$.
    
    \item Добавьте возможность вставлять новые элементы за амортизационное время и память
    $O(1)$. Используйте идею динамических массивов.

  \end{enumerate}

  \item Обычно в хэш-таблицах используется одна хэш-функция. Мы заведем две $f : K \rightarrow [m]$
   $g : K \rightarrow [m]$. Будем поддерживать инвариант, что любой элемент $x$ лежит либо в ячейке
    $T[f(x)]$, либо в $T[g(x)]$. Если разместить все ключи не получается, выберем
    новую пару функций и перемешаем таблицу. Возьмем $m = 4n$, где $n$ число ключей,
    которые будут добавлены.

    \begin{enumerate}
      \item Придумайте процедуры вставки, удаления и проверки элемента в 
        таблице. При добавлении можно считать, что всегда есть расположение текущих
        элементов, согласующееся с инвариантом.

      \item Нарисуйте граф на $m$ вершинах. Для каждого элемента, который есть в таблице,
        добавьте ребро $(f(x), g(x))$. Пусть функции $f$ и $g$ являюстя $t$-независимыми.
        Разрешим процедуре вставки сделать не более $t$ шагов. Найдите мат. ожидание
        числа шагов во время вставки.

      \item Дайте оценку сверху на вероятность сделать $t$ шагов, при условии, что ни 
        один элемент не будет перемещен дважды. На графе это соответствует обычному пути.

      \item Пусть при вставке, мы дошли обратно до элемента $x$, переместили его в ячейку
        $g(x)$, но дальше в цикл не попали. Оцените вероятность, что мы сделаем $t$ шагов.
  
      \item Оцените вероятность, что в предыдущем пункте, после перехода в ячейку $g(x)$
        мы попадем в путей. Используйте счетный аргумент.

      \item Подберите $t$ так, чтобы вероятность перемешивания таблицы была $O(n^{-2})$.
      
      \item Докажите, что при соответствующем $t$, такое хэширование использует $O(n)$ памяти,
        все процедуры работают амортизационно по мат. ожиданию $O(1)$.
        
    \end{enumerate}
  \item Пусть у нас есть структура данных, которая поддерживает множество $S$.
    Мы добавляем новые элементы в множество и проверяем текущие на 
    принадлежность. Проверка стоит дорого, поэтому мы построим специальный 
    фильтр Блума (англ. Bloom filter) между пользователем и структурой данных. 
    Фильтр позволит отбросить те элементы, которые точно не лежат в $S$. 

    Фильтр Блума состоит из битового массива длины $m$. Изначально массив 
    заполнен нулями. Мы подберем $k$ различных хеш-функций 
    $h_1, …, h_k : K \rightarrow [m]$
    так, чтобы 
    $$\textbf{Pr}_{x \leftarrow D(K)}\left[\bigwedge h_i(x) = y_i\right] 
      = O\left(\frac{1}{m^k}\right).$$
    Т.е. при известном распределении на входе, функции должны распределять $x$
    равномерно на выходе.

    Чтобы добавить элемент $x$ запишем единицу в позиции $h_1(x), …, h_k(x)$.

    Чтобы проверить, есть ли элемент $x$ в $S$, проверим биты в позициях
    $h_1(x), …, h_k(x)$. Если обнаружен хотя бы один ноль, то $x \not\in S$.
    Иначе, $x$ может принадлежать $S$. Ситуацию, когда элемент $x \not\in S$, но 
    все соответствующие ему биты равны единице, назовем ложным срабатыванием.

    \begin{enumerate}
      \item
        Оценить вероятность ложного срабатывания при проверке на принадлежность.
        Считать, что в $S$ лежит $n$ элементов.
      \item
        Найти оптимальное число хэш функций при фиксированных $m$ и $n$.
      \item
        Найти размер фильтра Блума такой, что вероятность ложного
        срабатывания не больше $\frac{1}{2}$.
      \item
        Пусть функции $h_1, …, h_k$ только попарно независимы. Как изменятся 
        ответы на предыдущие вопросы?
      \item
        Пусть известны две попарно независимые функции $f_1, f_2 : K \rightarrow [m]$,
        равномерно распределяющие $x$ при условии, вход идет согласно распределению $Q$.
        
        Постройте три попарно независимые функции $h_1, h_2, h_3: K \rightarrow [m]$,
        равномерно распределяющие $x$ при условии, вход идет согласно распределению $Q$.

        Считайте $m$ большим простым числом.
      \item
        Чтобы объединить два одинаковых фильтра Блума (совпадают размеры и 
        хэш-функции, могут различаться множества), достаточно провести 
        побитовое \textbf{ИЛИ} на массивах. Можно ли также получить 
        пересечение?

        Построим пересечение двух фильтров на множествах $A$ и $B$ с помощью 
        побитового \textbf{И}. Оцените вероятность ложного срабатывания 
        в новом фильтре. Размер пересечения $A$ и $B$ известен.

      \item
        Пусть в фильтре Блума есть $x$ ненулевых бит. В 2007 году Свамидасс и Балди 
        показали, что число элементов в фильтре Блума можно оценить как $n =
        -\frac{m\ln{(1-\frac{x}{m})}}{k}$.
        
        Оцените число элементов в пересечении и обьединении множеств, соответствующих 
        двум заданным фильтрам.

      \item
        Научимся удалять элементы из множества. Нужно обновлять состояние 
        фильтра.
        
        Один из вариантов --- хранить не биты, а число попаданий в данную 
        позицию. 

        Пусть для хранения числа попаданий используется используется $l$-битное 
        слово. При переполнении число попаданий устанавливается в бесконечность.

        Пусть число добавлений $n$. Оцените вероятность того, что хотя бы одно 
        из слов будет установлено в бесконечность. Распределении входов считать
        равномерным.
    \end{enumerate}



\end{itemize}


\subsection{Домашнее задание. Теория}
\textbf{Дедлайн: 26 марта, 23.59}

\begin{enumerate}

  \item 
\end{enumerate}

\subsection{Что почитать...}

\begin{itemize}

% \item http://habrahabr.ru/post/142589/ -- полиномиальное хэширование, статья на Хабре.
% \item http://www.mii.lt/olympiads_in_informatics/pdf/INFOL119.pdf -- более взрослая статья поляков
\item Про локально-чувствительные хэш-функции подробно написано в \href{http://infolab.stanford.edu/~ullman/mmds/book.pdf}{книжке Ульмана}
  
\end{itemize}


\clearpage
