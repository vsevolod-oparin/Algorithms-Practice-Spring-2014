\section{Практика 4. RMQ и LCA}

\subsection{Практика}

\begin{enumerate}

  \item Дан массив \texttt{a} длины $n$. Программе приходят запросы двух типов.
    \begin{itemize}
      \item Изменить значение в ячейке \texttt{a[i]}.
      \item Посчитать, сколько раз достигается локальный минимум на подотрезке \texttt{[l, r)}.
    \end{itemize} 
    \textbf{Пример}. На в последовательности $1, 2, 3, 1, 2$ минимум достигается два раза.
    Требуется реализовать алгоритм, обрабатывающий все запросы за $O(\log n)$.

  \item Дано дерево $T$ из $n$ вершин. Расстоянием для вершин $u$ и $v$ дерева $T$
    назовем число ребер в пути от $u$ до $v$; обозначим через $\texttt{dist}(u, v)$.
    Требуется уметь за $O(\log n)$ отвечать на запросы "Какого расстояние $\texttt{dist}(u,v)$ 
    для заданных $u$ и $v$?"
    \hint{использовать LCA.}

  \item Дано дерево $T$ из $n$ вершин. Разрешается сделать предобработку дерева.
  Требуется уметь за $O(1)$ отвечать запросы следующего типа.
  \begin{itemize}
    \item По заданным вершинам $u$ и $v$ определить, является ли эта пара предком-потомком.
    Если да, вернуть предка.
  \end{itemize}   

 

\end{enumerate}


\subsection{Домашнее задание. Программирование}
\textbf{Дедлайн: 23 марта, 23.59}

\begin{enumerate}

  \item Сдать \href{http://contest.yandex.com/contest/Contest.html?contestId=484}{яндекс-контест}.

\end{enumerate}

\subsection{Домашнее задание. Теория}
\textbf{Дедлайн: 12 марта, 23.59}

\begin{enumerate}

  \item Дан массив \texttt{a} длины $n$. Ячейки массива можно покрасить в $n^c$ цветов
  для произвольной константы $c$. Программе приходят запросы трех типов.
  \begin{itemize}
    \item Покрасить отрезок $\texttt{[l, r)}$ за $O(\log n)$ в цвет $x$.
    \item Вернуть цвет ячейки $\texttt{a[i]}$ за $O(\log n)$.
    \item Вернуть покраску всего массива за $O(n)$.
  \end{itemize}

  \item Дан массив $\texttt{a}$ длины $n$. Каждая ячейка хранит значение от $0$ до $n^c$
    для произвольной константы $c$.
    Программе приходят запросы двух типов.
    \begin{itemize}
      \item Поменять значение $\texttt{a[i]}$ ячейки.
      \item Для ячейки $\texttt{a[i]}$ найти первый меньший $\texttt{a[i]}$ элемент справа (такой, что $j > i$ и $\texttt{a[j]} < \texttt{a[i]}$).
    \end{itemize}
    Все запросы требуется обработать за $O(\log n)$.	

  \item Рассмотрим бинарную скошенную систему исчисления. На каждой позиции в 
  скошенной записи числа может стоять цифра 0, 1 или 2. Число 
  $a_k a_{k-1} \cdots a_2 a_1$ в скошенной системе переводится
  в десятичную по формуле $\sum_{i = 1}^k a_i \cdot (2^i - 1)$.

  В скошенной системе исчисления есть два ограничения: цифра 2 может 
  встречаться в записи не более одного раза; все цифры следующих меньших 
  разрядов равны нулю. Докажите, что каждое неотрицательное целое число имеет 
  ровно одну возможную запись в скошенной системе исчисления.

  Пример первых чисел: $0,\,1,\,2,\,10,\,11,\,12,\,20,\,100,\,101\dots$
  
  \item (*) Дано дерево из одной вершины. Требуется уметь отвечать на следующий
  набор за $O(\log n)$:
  \begin{itemize} 
    \item Подвесить новую вершину $u$ к вершине дерева $v$ и вернуть диаметр 
  дерева.
  \end{itemize}
  Диаметр дерева -- это длина самого длинного пути в дереве.

\end{enumerate}

\subsection{Что почитать...}

\begin{itemize}
  
  \item Статья Тарьяна про \href{http://www.lb.cs.cmu.edu/afs/cs.cmu.edu/user/sleator/www/papers/pairing-heaps.pdf}{спариваемые кучи}.

  \item Более сильные оценки на время работы парных куч можно прочитать \href{http://web.eecs.umich.edu/~pettie/papers/focs05.pdf}{здесь}.

  \item Сливаемые кучи можно использовать, например, в алгоритме Черитона-Тарьяна для поиска MST. Прочитать про него можно в книжке Тарьяна, на которую я ссылался раньше.

  \item Еще один метод поиска LCA производится через технику \href{http://neerc.ifmo.ru/wiki/index.php?title=%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D0%BE%D0%B4%D1%8A%D0%B5%D0%BC%D0%B0}{двоичного подъема}.

\end{itemize}


\clearpage
